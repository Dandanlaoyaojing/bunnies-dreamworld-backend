# 前端-数据隔离与移动操作更新说明

## 📋 更新内容

后端要求实现**完全的数据隔离**和**移动操作**（移动而非复制），确保：
1. 草稿箱、回收站和笔记簿使用完全独立的存储空间
2. 笔记在这三个库之间移动时，必须从源库删除，添加到目标库

---

## 🔧 需要理解的概念

### 1. 数据隔离

**三个独立的存储空间**：

| 存储空间 | 存储键 | 访问方法 | 包含内容 |
|---------|--------|---------|---------|
| **常规笔记（笔记簿）** | `userAccounts[accountName].notes` | `getNotesFromAccount()` | 只包含活跃的常规笔记 |
| **草稿箱** | `drafts_${accountName}` | `getAccountStorage('drafts')` | 只包含草稿 |
| **回收站** | `noteTrash_${accountName}` | `getTrashedNotes()` | 只包含已删除笔记 |

**关键原则**：
- ❌ 常规笔记库中**绝对不包含**草稿和已删除笔记
- ❌ 草稿箱中**绝对不包含**常规笔记和已删除笔记
- ❌ 回收站中**绝对不包含**常规笔记和草稿

### 2. 移动操作（移动而非复制）

**移动操作流程**：
```javascript
1. 从源库删除数据
2. 添加到目标库
3. 验证数据确实移动
```

**不允许的操作**：
- ❌ 只添加到目标库，不删除源库数据（这是复制，不是移动）
- ❌ 数据同时存在于多个存储空间

---

## 📝 操作示例

### 1. 删除笔记 → 移到回收站

**完整流程**：

```javascript
// 步骤1：从常规笔记库移除
const remainingNotes = activeNotes.filter(n => n.id !== noteId)
saveNotesToAccount(accountName, remainingNotes)

// 步骤2：添加到回收站
saveNoteToTrash(accountName, noteToDelete)

// 步骤3：验证
// - 验证笔记不在常规笔记库中
// - 验证笔记在回收站中
```

**关键点**：
- ✅ 先从常规笔记库删除
- ✅ 再添加到回收站
- ✅ 操作后验证数据确实移动
- ✅ 如果失败，回滚操作

### 2. 恢复笔记 → 移到常规笔记库

**完整流程**：

```javascript
// 步骤1：从回收站移除
removeNoteFromTrash(accountName, noteId)

// 步骤2：清理删除标记
delete restoredNote.status
delete restoredNote.deleteTime
delete restoredNote.deleted
delete restoredNote.isDeleted

// 步骤3：添加到常规笔记库
saveNotesToAccount(accountName, currentNotes)

// 步骤4：验证
// - 验证笔记不在回收站中
// - 验证笔记在常规笔记库中
// - 验证笔记没有删除标记
```

**关键点**：
- ✅ 先从回收站删除
- ✅ 清理所有删除相关标记
- ✅ 再添加到常规笔记库
- ✅ 操作后验证数据确实移动和标记清理

### 3. 发布草稿 → 移到常规笔记库

**完整流程**：

```javascript
// 步骤1：添加到常规笔记库
const note = {
  ...draft,
  isDraft: false
}
saveNote(note)

// 步骤2：从草稿箱移除
const updatedDrafts = drafts.filter(d => d.id !== draft.id)
setAccountStorage('drafts', updatedDrafts)

// 步骤3：验证
// - 验证草稿不在草稿箱中
// - 验证笔记在常规笔记库中
// - 验证笔记没有草稿标记
```

**关键点**：
- ✅ 先添加到常规笔记库
- ✅ 再从草稿箱删除
- ✅ 确保笔记不是草稿（`isDraft === false`）
- ✅ 操作后验证数据确实移动

### 4. 彻底删除 → 从回收站删除

**完整流程**：

```javascript
// 步骤1：验证笔记在回收站中
const noteInTrash = trashNotes.find(n => n.id === noteId)

// 步骤2：从回收站移除
removeNoteFromTrash(accountName, noteId)

// 步骤3：验证
// - 验证笔记不在回收站中
// - 验证笔记不在常规笔记库中（应该不在）
```

**关键点**：
- ✅ 验证笔记在回收站中（防止误删）
- ✅ 从回收站彻底删除
- ✅ 操作后验证笔记确实不存在

---

## ⚠️ 关键要点

### 1. **存储空间必须隔离**

```javascript
// ✅ 正确：从常规笔记库读取
const notes = noteManager.getNotesFromAccount(accountName)

// ✅ 正确：从草稿箱读取
const drafts = noteManager.getAccountStorage('drafts', [])

// ✅ 正确：从回收站读取
const trashNotes = noteManager.getTrashedNotes(accountName)

// ❌ 错误：不要混合读取
// const allData = [...notes, ...drafts, ...trashNotes] // 不要这样做
```

### 2. **操作必须是移动，不是复制**

```javascript
// ✅ 正确：删除笔记（移动操作）
// 步骤1：从常规库删除
saveNotesToAccount(accountName, remainingNotes)
// 步骤2：添加到回收站
saveNoteToTrash(accountName, noteToDelete)

// ❌ 错误：只添加不删除（这是复制）
// saveNoteToTrash(accountName, noteToDelete)
// // 但没有从常规库删除
```

### 3. **操作后必须验证**

```javascript
// ✅ 正确：删除笔记后验证
const verifyNotes = noteManager.getNotesFromAccount(accountName)
const stillExists = verifyNotes.notes.find(n => n.id === noteId)
if (stillExists) {
  console.error('❌ 验证失败：笔记仍在常规库中')
}

const verifyTrash = noteManager.getTrashedNotes(accountName)
const existsInTrash = verifyTrash.notes.find(n => n.id === noteId)
if (!existsInTrash) {
  console.error('❌ 验证失败：笔记未在回收站中')
}
```

### 4. **操作失败必须回滚**

```javascript
// ✅ 正确：如果添加到目标库失败，回滚源库的删除
if (!saveToTrash) {
  // 回滚：恢复常规笔记列表
  saveNotesToAccount(accountName, activeNotes)
  return { success: false, error: '操作已回滚' }
}
```

---

## 📍 需要检查的文件

根据前端代码结构，相关文件位于：

1. **笔记管理服务**
   - `utils/noteManager.js`
   - 关键方法：
     - `softDeleteNote()` - 删除笔记（移到回收站）
     - `restoreNote()` - 恢复笔记（移到常规库）
     - `permanentDeleteNote()` - 彻底删除
     - `saveNotesToAccount()` - 保存笔记（自动过滤草稿和已删除）
     - `getNotesFromAccount()` - 获取笔记（自动过滤）

2. **草稿箱页面**
   - `pages/draft-box/draft-box.js`
   - 关键方法：
     - `performPublishDraft()` - 发布草稿（移到常规库）
     - `performDeleteDraft()` - 删除草稿

3. **回收站页面**
   - `pages/trash/trash.js`
   - 关键方法：
     - `confirmRestore()` - 恢复笔记
     - `confirmPermanentDelete()` - 彻底删除

4. **笔记列表页面**
   - `pages/my-notes/my-notes.js` - 删除笔记
   - `pages/notebook/notebook.js` - 删除笔记
   - `pages/note-detail/note-detail.js` - 删除笔记

---

## ✅ 检查清单

前端代码应该确保：

### 数据隔离
- [ ] 常规笔记库只包含活跃的常规笔记（不包含草稿和已删除笔记）
- [ ] 草稿箱只包含草稿（不包含常规笔记和已删除笔记）
- [ ] 回收站只包含已删除笔记（不包含常规笔记和草稿）
- [ ] `saveNotesToAccount()` 自动过滤草稿和已删除笔记
- [ ] `getNotesFromAccount()` 自动过滤草稿和已删除笔记

### 移动操作
- [ ] 删除笔记：从常规库删除，添加到回收站
- [ ] 恢复笔记：从回收站删除，添加到常规库，清理删除标记
- [ ] 发布草稿：从草稿箱删除，添加到常规库，清除草稿标记
- [ ] 彻底删除：从回收站彻底删除
- [ ] 删除草稿：从草稿箱彻底删除

### 操作验证
- [ ] 每个移动操作后验证数据确实移动
- [ ] 验证数据标记是否正确（删除标记、草稿标记等）
- [ ] 记录验证失败的日志

### 回滚机制
- [ ] 如果移动到目标库失败，自动回滚源库的删除
- [ ] 确保操作是原子性的（要么全部成功，要么全部失败）

---

## 🧪 测试方法

### 1. 测试数据隔离

**测试常规笔记库**：
1. 创建一个常规笔记
2. 创建一个草稿
3. 删除一个笔记（移到回收站）
4. 获取常规笔记列表
5. **验证**：常规笔记列表中只包含第1步创建的笔记，不包含草稿和已删除笔记

**测试草稿箱**：
1. 创建几个草稿
2. 创建一个常规笔记
3. 删除一个笔记（移到回收站）
4. 获取草稿列表
5. **验证**：草稿列表中只包含第1步创建的草稿，不包含常规笔记和已删除笔记

**测试回收站**：
1. 删除几个笔记（移到回收站）
2. 创建几个常规笔记
3. 创建几个草稿
4. 获取回收站列表
5. **验证**：回收站列表中只包含第1步删除的笔记，不包含常规笔记和草稿

### 2. 测试移动操作

**测试删除笔记**：
1. 创建一个笔记（在常规笔记库中）
2. 删除这个笔记
3. **验证**：
   - 笔记不在常规笔记库中
   - 笔记在回收站中

**测试恢复笔记**：
1. 从回收站恢复一个笔记
2. **验证**：
   - 笔记不在回收站中
   - 笔记在常规笔记库中
   - 笔记没有删除标记（`status !== 'deleted'`, `isDeleted !== true`）

**测试发布草稿**：
1. 创建一个草稿（在草稿箱中）
2. 发布这个草稿
3. **验证**：
   - 草稿不在草稿箱中
   - 笔记在常规笔记库中
   - 笔记没有草稿标记（`isDraft !== true`, `status !== 'draft'`）

### 3. 测试回滚机制

**测试删除笔记失败回滚**：
1. 模拟保存到回收站失败（可以临时修改代码）
2. 删除一个笔记
3. **验证**：笔记仍在常规笔记库中（操作已回滚）

**测试发布草稿失败回滚**：
1. 模拟草稿不存在的情况
2. 尝试发布草稿
3. **验证**：如果保存到常规库成功但草稿不存在，应该回滚刚添加的笔记

---

## 📞 如有问题

如果更新后仍有问题，请检查：

1. **控制台日志**：查看操作日志和验证结果
   - 是否显示 "✅ 验证成功" 或 "❌ 验证失败"
   - 是否有回滚操作的日志

2. **数据存储**：使用开发者工具的 Storage 面板检查
   - `userAccounts` - 常规笔记库
   - `drafts_${accountName}` - 草稿箱
   - `noteTrash_${accountName}` - 回收站

3. **操作流程**：确认每个操作是否按照以下顺序执行
   - 步骤1：从源库删除
   - 步骤2：添加到目标库
   - 步骤3：验证操作

---

## 📄 相关文档

- `数据隔离与移动操作接口说明.md` - 详细的接口文档
- `数据隔离与移动操作问题诊断与修复.md` - 问题分析和修复说明

---

## 🎯 总结

**核心原则**：
1. **数据隔离**：三个存储空间完全独立，互不干扰
2. **移动操作**：所有跨存储空间的操作都是移动，不是复制
3. **操作验证**：每个操作后验证数据确实移动
4. **回滚机制**：操作失败时自动回滚，确保数据一致性

**一句话**：笔记在这三个库之间移动时，必须从源库删除，添加到目标库，并验证操作成功。

---

## 💡 最佳实践

1. **总是验证操作结果**：每个移动操作后都要验证数据是否真的移动
2. **记录详细日志**：所有操作都应该有详细的日志，方便排查问题
3. **实现回滚机制**：如果移动到目标库失败，应该回滚源库的删除操作
4. **保持数据隔离**：确保三个存储空间的数据不会混合


